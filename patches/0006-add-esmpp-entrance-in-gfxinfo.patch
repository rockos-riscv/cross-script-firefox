From ab2509826264d22e5ec441c581460194817ef951 Mon Sep 17 00:00:00 2001
From: CHEN <chenxuan@iscas.ac.cn>
Date: Thu, 16 Oct 2025 09:56:33 +0000
Subject: [PATCH 06/12] add esmpp entrance in gfxinfo

---
 widget/gtk/GfxInfo.cpp | 70 +++++++++++++++++++++++++++++++++++++++---
 1 file changed, 66 insertions(+), 4 deletions(-)

diff --git a/widget/gtk/GfxInfo.cpp b/widget/gtk/GfxInfo.cpp
index e7995749df..a285803acb 100644
--- a/widget/gtk/GfxInfo.cpp
+++ b/widget/gtk/GfxInfo.cpp
@@ -854,17 +854,79 @@ void GfxInfo::V4L2ProbeDevice(nsCString& dev) {
   }
 }
 
+
+//#ifdef MOZ_ENABLE_ESMPP
+
 void GfxInfo::GetDataESMPP() {
   if (mIsESMPPSupported.isSome()) {
     return;
   }
-  mIsESMPPSupported = Some(true);
+  mIsESMPPSupported = Some(false);
+
+  char* esmppData = nullptr;
+  auto free = mozilla::MakeScopeExit([&] { g_free((void*)esmppData); });
+
+  int esmppPipe = -1;
+  int esmppPID = 0;
+  const char* args[] = {nullptr};
+  esmppPID = FireTestProcess(ESMPP_PROBE_BINARY, &esmppPipe, args);
+  if (!esmppPID) {
+    return;
+  }
 
+  if (!ManageChildProcess("esmpptest", &esmppPID, &esmppPipe,
+                          ESMPP_TEST_TIMEOUT, &esmppData)) {
+    gfxCriticalNote << "esmpptest: ManageChildProcess failed\n";
+    return;
+  }
 
-  mVAAPISupportedCodecs = CODEC_HW_H264;
+  char* bufptr = esmppData;
+  char* line;
+  while ((line = NS_strtok("\n", &bufptr))) {
+    if (!strcmp(line, "SUPPORTED")) {
+      line = NS_strtok("\n", &bufptr);
+      if (!line) {
+        gfxCriticalNote << "esmpptest: Failed to get ESMPP support\n";
+        return;
+      }
+      mIsESMPPSupported = Some(!strcmp(line, "TRUE"));
+    } else if (!strcmp(line, "HWCODECS")) {
+      line = NS_strtok("\n", &bufptr);
+      if (!line) {
+        gfxCriticalNote << "esmpptest: Failed to get ESMPP codecs\n";
+        return;
+      }
 
-  media::MCSInfo::AddSupport(
-      media::MediaCodecsSupport::H264HardwareDecode);
+      std::istringstream(line) >> mESMPPSupportedCodecs;
+      if (mESMPPSupportedCodecs & CODEC_HW_DEC_H264) {
+        media::MCSInfo::AddSupport(
+            media::MediaCodecsSupport::H264HardwareDecode);
+      }
+      if (mESMPPSupportedCodecs & CODEC_HW_DEC_VP8) {
+        media::MCSInfo::AddSupport(
+            media::MediaCodecsSupport::VP8HardwareDecode);
+      }
+      if (mESMPPSupportedCodecs & CODEC_HW_DEC_VP9) {
+        media::MCSInfo::AddSupport(
+            media::MediaCodecsSupport::VP9HardwareDecode);
+      }
+      if (mESMPPSupportedCodecs & CODEC_HW_DEC_AV1) {
+        media::MCSInfo::AddSupport(
+            media::MediaCodecsSupport::AV1HardwareDecode);
+      }
+      if (mESMPPSupportedCodecs & CODEC_HW_DEC_HEVC) {
+        media::MCSInfo::AddSupport(
+            media::MediaCodecsSupport::HEVCHardwareDecode);
+      }
+    } else if (!strcmp(line, "WARNING") || !strcmp(line, "ERROR")) {
+      gfxCriticalNote << "esmpptest: " << line;
+      line = NS_strtok("\n", &bufptr);
+      if (line) {
+        gfxCriticalNote << "esmpptest: " << line << "\n";
+      }
+      return;
+    }
+  }
 }
 
 const nsTArray<RefPtr<GfxDriverInfo>>& GfxInfo::GetGfxDriverInfo() {
-- 
2.48.1

